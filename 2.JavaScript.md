### 目录

<a href='#1'>一、说说数据类型、检测方式、数据存储？</a>

<a href='#2'>二、说说null和undefined？</a>

<a href='#3'>三、强制类型转化和隐式类型转化？</a>

<a href='#4'>四、列举常用的数组方法？</a>





## <a name='1'>一、说说数据类型、检测方式、数据存储？</a>

#### 1、数据类型

- 简单数据类型：null、undefined、String、Number、symbol、Bigint、Boolean，
- 复杂（引用）数据类型：Object对象（Array，Function 、Date、Math等等）

#### 2、检测数据类型的方法

- `typeof`:返回一个字符串

  ```js
  1.typeof null 结果为object
  2.typeof 2/1 结果为NAN 优先级大于运算符
  ```

- `instanceof`:返回一个布尔值，只能检测复杂数据类型

- `Object.prototype.toString.call()`:这是最优的方法

#### 3、数据存储

- js中简单数据类型直接存在栈内存中
- 引用数据则是将数据存在堆内，在栈中存引用数据类型的引用地址，地址指向堆内存的引用数据



## <a name='2'>二、说说null和undefined？</a>

- null和undefined都是js基本数据类型
- 当使用严格相等 `===` 比较二者时，它们不相等，因为它们属于不同的类型。
- 当使用非严格相等 `==` 比较二者时，JavaScript 存在一个特殊的规则，**会判定它们相等。**它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值。
- 当使用数学式或其他比较方法 `< > <= >=` 时：null/undefined会被转化为数字：`null` 被转化为 `0`，`undefined` 被转化为 `NaN`。
- 另外，在做boolean 转换时 null 、0、' ' 、undefined、NaN都会被转化为false



## <a name='3'>三、列举强制类型转化和隐式类型转化?</a>

#### 1、强制类型转化

- 转化成字符串 `toString()`， `String()`

- 转换成数字 `Number()`、 `parseInt()`、 `parseFloat()`

  -  `Number()`的方法的规则为：只要需要转化的字符串有不是数字的就会返回NaN

    ```js
    console.log(Number('12abc'))//结果为NaN
    ```

  -  `parseInt()`：转换为number类型 并且保留整数部分，需要转换的数据只要出现字符就会直接返回该字符之前数字部分

    ```js
    console.log(parseInt('12abc'))//结果为12
    ```

  -  `parseFloat()`：转换为number类型 ,并返回一个浮点数。

#### 2、隐式类型转化

- 字符串的拼接，`任何数据+字符串`结果都为字符串

- 字符串转化为数字
  - `+str`：在字符串前面加个`+`就能将字符串转化为数字
  - 除了加法运算以外的运算都能将字符串转化为数字
  
  ```js
  什么情况下会发生布尔值的隐式强制类型转换？
  （1） if (..) 语句中的条件判断表达式。
  （2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
  （3） while (..) 和 do..while(..) 循环中的条件判断表达式。
  （4） ? : 中的条件判断表达式。
  （5） 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
  ```
  
  

## <a name='4'>四、列举常用的数组方法？</a>

#### 1、破坏性方法

破坏性方法表示方法会改变原数组

- `push`

  在数组的末尾添加一个元素或者多个元素，并返回数组的新长度

- `unshift()`

  在数组的开头添加一个元素或者多个元素，并返回数组的新长度

  ```js
  let arr = ['a', 'b', 'c']
          arr.push('d')
          console.log(arr);
          console.log(arr.push());//['a', 'b', 'c','d']
  
          arr.unshift('A')
          console.log(arr);
          console.log(arr.unshift());//['A','a', 'b', 'c','d']
  ```

- `pop()`

  删除数组的最后一个元素，返回值的被删除的元素

- `shift()`

  删除数组的第一个元素，返回值的被删除的元素

- `splice(开始删除的位置，删除的元素个数)`

  第二个参数不写表示从第一个参数下标开始删除后面的所有元素，返回值是被删除的元素组成的数组

  splice 也可以添加元素 ： splice （起始位置，0 ，添加的元素，添加的元素...），但是添加元素返回的是空数组,只是改变了原数组

- `sort()`

  ```js
  sort( function(a,b){ return a-b})//这是升序 b-a则是降序
  ```

- `reserve()`

  反转原数组，返回反转后的数组

#### 2、非破坏性方法

非破坏性方法表示方法不会改变原数组

- `slice （截取的起始位置，截取的结束位置）`：前闭后开

  截取数组片段，返回一个新截取的数组 不改变原数组，第一个参数不写那么则会一直截取到最后，两个参数都省略可以对数组进行浅拷贝，返回一个新数组	

- `concat()`

  连接数组，返回一个新数组 

- `indexOf`（元素，开始查询此元素的位置）

  获取数组中元素第一次出现的索引，并返回它的索引，没有返回-1

- `lastIndexOf `

  和③ 相同 但是是从后往前找

- `join（分隔符）`

  将数组的元素连接成一个字符串，默认元素之间用逗号隔开，在小括号里面可以指定元素之间的符号 如join（@）：这表示元素之间用@符号隔开，返回一个字符串

- `map（function（item，index）{}）`

  map映射，返回一个新的数组，新数组由每个元素调用回调函数的返回值组成，也就是由回调函数的返回值组成，（有几个元素就有几个返回值）

  ```js
  const arr = ['张三','李四','王五']
      const res = arr.map(function(item,index){
        return 1
      })
      console.log(res);//res[1,1,1]
  ```

- `filter（回调函数作为参数，一般要写返回值，返回true或者false，函数里面传入的是 element，index，array ）`

  将数组中满足条件的保存到一个新数组中返回，根据回调函数的返回值决定是否将这个元素放入新数组

  ```js
  const arr = [10,20,30]
          const  res = arr.filter(function(item,index){
              return item > 10
          })
          console.log(res)
  ```

- `reduce（回调函数（pre,cur）{return pre + cur}，第二个参数：初始值）`

  逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果相加（上一步的计算结果是当前元素之前所有元素的总和）——直到没有更多的元素被相加。

  ```js
  		// 语法：arr.reduce(function(){}, initValue)
          // 作用：对数组里面的每个元素都执行一个自定义的reducer函数，将其结果汇总为单个返回值。
          //   参数 ： 
          //       callbackFn : 回调函数   必须 √
          //       initValue  : 初始值 （可选） √
          // callbackFn的参数：   ==> 要写return
          //        previousValue :    上一次调用calbackFn 时的返回值  √
          //        currentValue  :    当前元素  √
          //        currentIndex  :    当前元素的索引  （可选）
          //        array         :     源数组 （可选）  
          //  返回值 ： 使用 “reducer” 回调函数遍历整个数组后的结果。
  ```

  ```js
   const arr = [{
              name: '张三',
              salary: 10000
          }, {
              name: '李四',
              salary: 10000
          }, {
              name: '王五',
              salary: 20000
          }]
          const res = arr.reduce(function (prv, cur) {
              return prv + cur.salary * 0.3//每一次将当前的元素与上一步的计算结果相加
          }, 0)//0时初始值，这里如果不写的话时数组里面的第一个对象
          console.log(res)
  ```

- `find（function（ele，index，当前数组））`

  搜索查找,返回数组中满足函数return条件的第一个元素，没有返回undefined

  ```js
  const arrTemp = [{name:'小米', price:1999},{name:'华为', price:5999}]
          const res = arrTemp.find(function(item,index){
              return item.name = "小米"
          })
          console.log(res)//{name:'小米', price:1999}
  ```

- `findIndex（function（ele，index， array）{return 。。。}）`

  返回满足return条件的数组元素的下标，没有返回 -1

- `arr.every(cbfn)`

  `cbfn`是回调函数，检测数组内元素是否都满足return指定条件，如果都满足，返回true，否则 返回false

- `arr.some(cbfn)`

  检测数组内元素至少有一个元素满足return指定条件，如果满足，返回true，否则 返回false

**⚠注**：`map` 、`filter` 、`forEach`、`find`、`findIndex`、`every`、`some`等传入回调函数的参数都是三个分别为：element（当前元素）、index（当前 元素索引）、array（被遍历的数组）且这些都能迭代数组

<hr>

总结：


#### 1、添加/删除元素

- `push(...items)` —— 向尾端添加元素，
- `pop()` —— 从尾端提取一个元素，
- `shift()` —— 从首端提取一个元素，
- `unshift(...items)` —— 向首端添加元素，
- `splice(pos, deleteCount, ...items)` —— 从 `pos` 开始删除 `deleteCount` 个元素，并插入 `items`到原数组中，（删除和添加同时进行）
- `slice(start, end)` —— 创建一个新数组，将从索引 `start` 到索引 `end`（但不包括 `end`）的元素复制进去。
- `concat(...items)` —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 `items`。如果 `items` 中的任意一项是一个数组，那么就取其元素。

#### 2、搜索元素

- `indexOf/lastIndexOf(item, pos)` —— 从索引 `pos` 开始搜索 `item`，搜索到则返回该项的索引，否则返回 `-1`。
- `includes(value)` —— 如果数组有 `value`，则返回 `true`，否则返回 `false`。
- `find/filter(func)` —— 通过 `func` 过滤元素，返回使 `func` 返回 `true` 的第一个值/所有值。
- `findIndex` 和 `find` 类似，但返回索引而不是值。

#### 3、遍历元素

- `forEach(func)` —— 对每个元素都调用 `func`，不返回任何内容。

#### 4、转换数组

- `map(func)` —— 根据对每个元素调用 `func` 的结果创建一个新数组。
- `sort(func)` —— 对数组进行原位排序，然后返回它。
- `reverse()` —— 原位反转数组，然后返回它。
- `split/join` —— 将字符串转换为数组并返回。
- `reduce/reduceRight(func, 初始值)` —— 通过对每个元素调用 `func` 计算数组上的单个值，并在调用之间传递中间结果。

#### 5、其他

- `Array.from()`: 将伪数组转化为真数组

- `Array.isArray(value)` 检查 `value` 是否是一个数组，如果是则返回 `true`，否则返回 `false`。

- 请注意，`sort`，`reverse` 和 `splice` 方法修改的是数组本身。


- `arr.flat(depth)`从多维数组指定深度创建一个新的扁平数组。返回一个新数组

#### 6、不常用方法

- `[arr.some(fn)]/[arr.every(fn)`检查数组。

  与 `map` 类似，对数组的每个元素调用函数 `fn`。如果任何/所有结果为 `true`，则返回 `true`，否则返回 `false`。

  这两个方法的行为类似于 `||` 和 `&&` 运算符：如果 `fn` 返回一个真值，`arr.some()` 立即返回 `true` 并停止迭代其余数组项；如果 `fn` 返回一个假值，`arr.every()` 立即返回 `false` 并停止对其余数组项的迭代。

  我们可以使用 `every` 来比较数组：

  ```js
  function arraysEqual(arr1, arr2) {
    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
  }
  
  alert( arraysEqual([1, 2], [1, 2])); // true
  ```

- `arr.fill(value, start, end)` —— 从索引 `start` 到 `end`，用重复的 `value` 填充数组。

- `arr.copyWithin(target, start, end)`—— 将从位置 `start` 到 `end` 的所有元素复制到 **自身** 的 `target` 位置（覆盖现有元素）。

- `Array.of(element0[, element1[, …[, elementN\]]])` 基于可变数量的参数创建一个新的 `Array` 实例，而不需要考虑参数的数量或类型。



## <a name='5'>五、var let const 区别</a>

- **块级作用域**：let、const 有块级作用域，var不存在块级作用域
  - 解决了ES5的两个问题：内层变量可能覆盖外层变量以及用来计数的变量泄露为全局变量
  - 另外局部变量在使用完之后就会被销毁
- **变量提升**:var声明的变量回提升到当前作用域的最上方，let和const没有
- **给全局添加属性**：var在全局作用域声明的变量回挂载到window上，let const 不会

- **重复声明**：var变量可以重复声明，let和const不能

- **暂时性死区**：let 和const 声明的变量会存在暂时性死区，在变量被定义之前不能使用该变量

- **初始值**：const声明的变量必须设置初始值，let和var可以不设置

- **指针指向**：let声明的变量可以改变指针指向，也就是可以重新赋值，const不能

  - 注意：如果const声明的变量指向的是一个引用类型，只要引用地址没改变，指针指向的数据是可以改变的

  

## <a name='6'>六、for....in 和 for.... of区别</a>

- for in 用于可枚举的数据，像是对象，数组，字符串，得到的是key

- for of 用于可迭代的数据，像 数组、字符串、Map、Set 得到的是value

- 可枚举可以用`Object.getOwnpropertyDescriptors(要检测的对象)`，可迭代可以查看`Symbol.interato`r属性里面的`next()`方法，有就是可迭代 

- 连环问：for await...of :用于遍历多个Promise

  ```js
  Promise.all([p1,p2,p3]).then(res=>console.log(res))//可以得到多个promise的执行resolve()的结果
  for await (let res of [p1,p2,p3]){
      console.log(res)//得到的也是多个promise的resolve()的结果
  }
  ```



## <a name='6'>七、 如何实现数组的随机排序？</a>

```js
//(1)
var arr = [1,2,3,4,5,6,7,8,9,10];
 arr.sort(function(){
 return Math.random() - 0.5;
 })
 console.log(arr);

// （2）随机从原数组抽取一个元素，加入到新数组
function randomSort(arr) {
  var result = [];

  while (arr.length > 0) {
    var randomIndex = Math.floor(Math.random() * arr.length);
    result.push(arr[randomIndex]);
    arr.splice(randomIndex, 1);
  }

  return result;
}

// （3）随机交换数组内的元素（洗牌算法类似）
function randomSort(arr) {
  var index,
    randomIndex,
    temp,
    len = arr.length;

  for (index = 0; index < len; index++) {
    randomIndex = Math.floor(Math.random() * (len - index)) + index;

    temp = arr[index];
    arr[index] = arr[randomIndex];
    arr[randomIndex] = temp;
  }

  return arr;
}

// es6
function randomSort(array) {
  let length = array.length;

  if (!Array.isArray(array) || length <= 1) return;

  for (let index = 0; index < length - 1; index++) {
    let randomIndex = Math.floor(Math.random() * (length - index)) + index;

    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];
  }

  return array;
}
```



## <a name='6'>八、伪数组和如何将伪数组转化为真数组</a>

#### 1、伪数组

- 具有 length 属性
- 按索引方式存储数据
- 不能使用数组的 push.pop 等方法但是可以用forEach等方法对其进行遍历

#### 2、转化为真数组的方法

- 用for of 迭代伪数组并将其每一个元素push进一个空数组
- Array.from(arguments)
- 展开运算符：newArr = [...arguments]
- Array.prototype.slice.call(arguments):在原型上调用slice的call方法
- cancat（）：空数组和伪数组连接



## <a name='6'>九、 原型、原型链、特点？</a>

- **原型**：

  ```js
  答：
  1.原型是一个对象，
  2.js中所有的函数都有prototype属性，指向它的原型对象，原型对象上有一个constructor指回函数本身
  3.当我们使用构造函数创建一个实例对象时，对象的内部有一个指针指向构造函数的prototype属性对应的值 ，在ES5中这个指针被称为对象的原型（函数也有这个），一般来说，我们不应该获取这个值，浏览器可以用__proto__属性来获取这个值，但是这是不规范的，
  我们应该用ES5的Object.getPrototypeOf()的方法来获取对象的原型
  
  参考：
  1、原型就是一个对象
  2、所有的函数都有一个prototype属性，指向它的原型对象
  3、所有对象都有一个__proto__属性 指向构造函数得到prototype ，也即是指向原型
  4、原型上默认有个constructor属性，指回构造函数
  
  5、作用 : 可以将属性和方法写在原型里面节约内存
  6、所有通过构造函数创建的对象都可以共享原型上的方法和属性
  ```

- **原型链**

  ```js
  当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又
  会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 
  ```

- **特点**：

  ```js
  JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与
  之相关的对象也会继承这一改变。
  ```

## <a name='6'>十、 作用域、作用链？</a>





