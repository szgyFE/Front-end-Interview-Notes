## <a name='1'>二、浏览器渲染原理？回流和重绘、script的defer和aync</a>







## <a name='2'>三、同源策略，解决跨域？</a>





## 四、聊一聊浏览器缓存

常说的浏览器缓存有两种，一种是强制缓存，一种是协商缓存。

- **协商缓存**：协商缓存意思是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置，下面会说到。需要注意的是协商缓存还是发了请求的
- **强制缓存**：强制缓存就是文件直接从缓存中获取，不需要发送请求

**缓存实现**

- 强制缓存

强制缓存在 http1.0 的时候用的是 Expires，是响应头里面的一个字段表示的是文件过期时间。是一个绝对时间，正因为是绝对时间所以在某些情况下，服务器的时区和浏览器时区不一致的时候就会导致缓存失效。为了解决这个问题，HTPP1.1 引入了一个新的响应头 cache-control 它的可选值如下

- cache-control
- max-age: 缓存过期时间，是一个相对时间
- public: 表示客户端和代理服务器都会缓存
- private: 表示只在客户端缓存
- no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
- no-store: 表示文件不会被缓存
  HTTP1.1 利用的就是 max-age:600 来强制缓存，因为是相对时间，所以不会出现 Expires 问题
- 协商缓存

协商缓存是利用 Last-Modified/if-Modified-Since,Etag/if-None-Match 这两对请求、响应头。

- Last-Modified/if-Modified-Since
- Etag/If-None-Match
  由于 Last-Modified 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以HTTP1.1又引入了 Etag 字段。这个字段是根据文件内容生成一个标记符比如”W/“5f9583bd-10a8””，然后再和 If-None-Match 进行对比就能更准确的知道文件有没有被改动过

浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个 if-Modified-Since，记录被改动的时间
浏览器第二次发送请求的时候会带上一个 Last-Modified 请求头，时间就是 if-Modified-Since 返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回 304 从缓存里面获取文件



